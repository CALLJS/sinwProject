{"version":3,"sources":["../../../../work/magiccube/js/MagicFace.js"],"names":["MagicFace","cubes","center","i","color","j","length","setFaceColor","theta","len","rotateVector","falg","order","sortarr","replaceFace","forEach","val","index","push","y","as","CubeUtil","getInstance","sort","isTopDis","vertexs1","vertexs2","refvertex","ctx","topface","getTop3Face","util","que","PriorityQueue","a","b","getDistance","resulr","m","con","top3","getTop3Vertex","isFaceCenter","vertices","arr","slice","clear","vers","key","va","v","Vertex","x","z","result","isPolygonContainsPoint","foperator","points","point","mPoints","nCross","p1","p2","Math","min","max"],"mappings":"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","file":"MagicFace.js","sourcesContent":["import {Vertex} from \"./Vertex.js\";\r\nimport {CubeUtil} from \"./CubeUtil.js\";\r\nimport {PriorityQueue} from \"../../../common/datastructures/PriorityQueue.js\";\r\n\r\nexport class MagicFace {\r\n    //i 表示第几个面 color这个面的颜色\r\n    constructor(cubes, center, i, color) {\r\n        this.i = i;\r\n        this.color = color;\r\n        this.cubes = cubes;\r\n        this.center = center;\r\n        for (var j = 0; j < cubes.length; j++) {\r\n            cubes[j].setFaceColor(this.i, color);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 绕坐标系原点（0，0，0）center  旋转\r\n     * @param center 空间中的一点\r\n     * @param theta 绕的角度\r\n     */\r\n    rotateFace(center, theta) {\r\n        var len = this.cubes.length;\r\n        for (var i = 0; i < len; i++) {\r\n            this.cubes[i].rotateVector(this.center, theta);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置cube属于旋转的面和面渲染的顺序\r\n     * @param falg 标识方块属于旋转的面\r\n     * @param order 设置方块所在面的渲染的顺序\r\n     */\r\n    setDisableCube(falg, order) {\r\n        var len = this.cubes.length;\r\n        let sortarr = [];\r\n        var replaceFace = [];\r\n        this.cubes.forEach(function (val, index) {\r\n            sortarr.push(val.center.y);\r\n        });\r\n        var as = CubeUtil.getInstance().sort(sortarr);\r\n        //一个面旋转的面最多显示6个块\r\n        for (var i = 0; i < 9; i++) {\r\n            this.cubes[i].order = order;\r\n            this.cubes[i].isTopDis = falg;\r\n        }\r\n    }\r\n\r\n    isPointInner(vertexs1, vertexs2, refvertex, ctx) {\r\n        var topface = this.getTop3Face(refvertex);\r\n        let cubes = this.cubes;\r\n        var util = CubeUtil.getInstance();\r\n\r\n        var que = new PriorityQueue(\r\n            (a, b) => {\r\n                var center = this.center;\r\n                return util.getDistance(a, center) > util.getDistance(b, center);\r\n            }\r\n        );\r\n\r\n        var resulr = {};\r\n        for (var m = 0; m < topface.length; m++) {\r\n            var con = false;\r\n            var top3 = this.getTop3Vertex(cubes, topface[m]);\r\n            for (var a = 0; a < 3; a++) {\r\n                if (top3[a].isFaceCenter) {\r\n                    con = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (con) {\r\n                continue;\r\n            }\r\n            for (var a = 0; a < 3; a++) {\r\n                for (var b = 0; b < 8; b++) {\r\n                    que.push(top3[a].vertices[b]);\r\n                }\r\n            }\r\n            resulr[m] = que.arr.slice(0, 4);\r\n            que.clear();\r\n        }\r\n\r\n        var vers = [];\r\n        for (var key in resulr) {\r\n            var val = resulr[key];\r\n            var va = [];\r\n            val.forEach((v,index)=>{\r\n                va.push(new Vertex(v.x+400,v.y,v.z+400));\r\n            })\r\n            vers.push(va);\r\n        }\r\n        // for (var i = 0; i < 4; i++) {\r\n        //     ctx.fillStyle = 'black';\r\n        //     ctx.beginPath();\r\n        //     ctx.arc(vers[0][i][0], vers[0][i][1], 5, 0, 2 * Math.PI);\r\n        //     ctx.stroke();\r\n        //     ctx.fill();\r\n        // }\r\n        // for(var i = 0;i < 4;i++){\r\n        //     ctx.fillStyle = 'black';\r\n        //     ctx.beginPath();\r\n        //     ctx.arc(vers[1][i][0] ,vers[1][i][1] ,5,0,2*Math.PI);\r\n        //     ctx.stroke();\r\n        //     ctx.fill();\r\n        // }\r\n        // ctx.fillStyle = 'black';\r\n        // ctx.beginPath();\r\n        // ctx.arc(vertexs1.x, vertexs1.z, 5, 0, 2 * Math.PI);\r\n        // ctx.stroke();\r\n        // ctx.fill();\r\n        // ctx.fillStyle = 'black';\r\n        // ctx.beginPath();\r\n        // ctx.arc(vertexs2.x, vertexs2.z, 5, 0, 2 * Math.PI);\r\n        // ctx.stroke();\r\n        // ctx.fill();\r\n\r\n\r\n        var result = false;\r\n        if (\r\n            this.isPolygonContainsPoint(vertexs1,vers[0]) && this.isPolygonContainsPoint(vertexs2,vers[0])\r\n        //this.insidePolygon(vertexs1.x, vertexs1.z, vers[0]) && this.insidePolygon(vertexs2.x, vertexs2.z, vers[0])\r\n        ) {\r\n            result = true;\r\n        }\r\n        if (\r\n            this.isPolygonContainsPoint(vertexs1,vers[1]) && this.isPolygonContainsPoint(vertexs2,vers[1])\r\n        //this.insidePolygon(vertexs1.x, vertexs1.z, vers[1]) && this.insidePolygon(vertexs2.x, vertexs2.z, vers[1])\r\n        ) {\r\n            result = true;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * 返回优先队列的比较器,如果返回true 则a插在b前面\r\n     */\r\n    foperator(refvertex) {\r\n\r\n        var util = CubeUtil.getInstance();\r\n        return (a, b) => {\r\n            return util.getDistance(a.center, refvertex) < util.getDistance(b.center, refvertex);\r\n        };\r\n    }\r\n\r\n    getTop3Face(refvertex) {\r\n        var que = new PriorityQueue(\r\n            (a, b) => {\r\n                return a.y > b.y;\r\n            }\r\n        );\r\n        // refvertex.forEach((val, index) => {\r\n        //     que.push(val);\r\n        // })\r\n        for (var key in refvertex) {\r\n            que.push(refvertex[key]);\r\n        }\r\n        return que.arr.slice(0, 3);\r\n    }\r\n\r\n    getTop3Vertex(cubes, refvertex) {\r\n        var que = new PriorityQueue(this.foperator(refvertex));\r\n        cubes.forEach((val, index) => {\r\n            que.push(val);\r\n        })\r\n        return que.arr.slice(0, 3);\r\n    }\r\n\r\n    insidePolygon(x, y, points) {\r\n        let result = false;\r\n        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {\r\n            if ((points[i][1] > y) != (points[j][1] > y) &&\r\n                (x < (points[j][0] - points[i][0]) * (y - points[i][1]) / (points[j][1] - points[i][1]) + points[i][0])) {\r\n                result = !result;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    isPolygonContainsPoint(point, mPoints) {\r\n        if(!point || !mPoints)\r\n            return false;\r\n        var nCross = 0;\r\n        for (var i = 0; i < mPoints.length; i++) {\r\n            var p1 = mPoints[i];\r\n            var p2 = mPoints[(i + 1) % mPoints.length];\r\n            // 取多边形任意一个边,做点point的水平延长线,求解与当前边的交点个数\r\n            // p1p2是水平线段,要么没有交点,要么有无限个交点\r\n            if (p1.z == p2.z)\r\n                continue;\r\n            // point 在p1p2 底部 --> 无交点\r\n            if (point.z < Math.min(p1.z, p2.z))\r\n                continue;\r\n            // point 在p1p2 顶部 --> 无交点\r\n            if (point.z >= Math.max(p1.z, p2.z))\r\n                continue;\r\n            // 求解 point点水平线与当前p1p2边的交点的 X 坐标\r\n            var x = (point.z - p1.z) * (p2.x - p1.x) / (p2.z - p1.z) + p1.x;\r\n            if (x > point.x) // 当x=point.x时,说明point在p1p2线段上\r\n                nCross++; // 只统计单边交点\r\n        }\r\n        // 单边交点为偶数，点在多边形之外 ---\r\n        return (nCross % 2 == 1);\r\n    }\r\n}"]}